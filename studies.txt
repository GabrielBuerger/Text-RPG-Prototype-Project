Computation
    The Theoretical Core: Control + State
    Control: conditionals and looping
    State: data (variables)

    programming paradigmas
        low-level:
            imperative (assembly): machine language
        mid-level:
            procedural (C, Pascal): list of actions, the base of everything is memory
        high-level:
            OOP (Smalltalk, C++, Java, Python): uses a second layer unifing data with functions
            OOP prototype (JavaScript): has objects but no classes, just objects cloning another ones via prototype chain
            functional (Lisp, Haskell, modern JS): list as matematical formulas
            declarative/reactive (SQL, HTML, React, Prolog): states goals, no matter the proccess

data prototypes:
    ":" is a type hint
    Static Typing ðŸ§Š	
        Types are checked at compile time	
        Errors found before the program runs	
        Variables have fixed types
    Dynamic Typing ðŸŒ€
        Types are checked at runtime
        Errors may appear while running
        Variables can hold any type at any time

Compound Data Structures
    â”‚
    â”œâ”€â”€ Ordered (sequence-like)
    â”‚   â”œâ”€â”€ Fixed-size
    â”‚   â”‚   â”œâ”€â”€ Dynamic values:
    |   |   |   Array (C, Java, NumPy, JS TypedArray)
    â”‚   â”‚   â””â”€â”€ Fixed values:
    |   |       Tuple (Python) 
    â”‚   â””â”€â”€ Dynamic-size
    â”‚       â”œâ”€â”€ List (Python) 
    â”‚       â”œâ”€â”€ Vector (C++ STL, Java Vector/ArrayList)
    â”‚       â””â”€â”€ Array (JS normal array, Java ArrayList)
    â”‚
    â”œâ”€â”€ Unordered (collection-like)
    â”‚   â”œâ”€â”€ Set (Python set, Java HashSet, C++ std::set, JS Set)
    â”‚   â””â”€â”€ Map / Dictionary
    â”‚       â”œâ”€â”€ Dict (Python)
    â”‚       â”œâ”€â”€ HashMap (Java), std::map (C++)
    â”‚       â””â”€â”€ Object/Map (JavaScript)
    â”‚
    â””â”€â”€ Specialized
        â”œâ”€â”€ Queue / Stack (collections.deque in Python, Queue in Java, std::queue in C++)
        â”œâ”€â”€ Linked Lists (manual in C, LinkedList in Java, JS libraries)
        â”œâ”€â”€ Trees, Graphs, etc. (built manually or with libraries)

    list
        ":" ---> my_list[1:4] ---> (1,2,3)

    Dictionary:
        self.my_dict = {"a": 1, "b": 2} ---> overwrite the old values to new ones
        self.my_dict: dict = dict() ---> overwrite old values to empty
        self.my_dict: dict ---> without the objects, it only state the type
        self.my_dict["new_key"] = "new_value" ---> update without overwritting
        self.my_dict.update({"key", "value"}) ---> update without overwritting
        self.my_dict: dict[str, int] = {"a": 1, "b": 2} ---> update without overwritting


Object oriented programing morphosyntatics
    The objects:
        SVO -> subject.verb(Object) / Object.Method(parameters)

        predicate/method(object's function)
            verb/method: intransitive(no objects/parameters) or transitive(one object/one or multiple parameters)
        
        subject/object
            adverbial adjunct: object.atribute(object's variable) / subject.adjective

    The classes:
        Inheritance = Taxonomic Hierarchy

        Noun <- lexicon = object <- class
        
        super(): inheritate the atributes(adjectives) and the methods(verbs)
    
    The root of everything:
        "type" class: class that create classes (that created itself)
        "object" class: provide all dunder methods(methods applied to objects, especifically)
    
    Use object or function? (as semantics)
        Object: act upon anothero object
        Function: is a blackground setting for object, where things happens

functions
    def function (parameter:prime_type | second_primetype_option = default value, 
                  parameter:list[prime_type])

